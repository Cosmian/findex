use cosmian_crypto_core::kdf256;

use crate::{CsRhDxEnc, DbInterface, Edx, Error, Token, TAG_LENGTH};

use super::{
    primitives::{Dem, Kmac, MIN_SEED_LENGTH},
    structs::Tag,
    Dx, DynRhDxEnc, TagSet,
};

#[derive(Debug)]
pub struct Vera<const VALUE_LENGTH: usize, DbConnection: DbInterface> {
    connection: DbConnection,
    kmac: Kmac,
    dem: Dem,
}

impl<const VALUE_LENGTH: usize, DbConnection: DbInterface> Vera<VALUE_LENGTH, DbConnection> {
    const TOKEN_INFO: &'static [u8] = b"Token derivation info.";

    /// Returns the token associated to the given tag.
    fn tokenize(&self, tag: &Tag) -> Token {
        self.kmac.hash(tag, Self::TOKEN_INFO)
    }

    /// Returns the EDX corresponding to the given DX.
    fn prepare(
        &self,
        dx: &Dx<VALUE_LENGTH>,
    ) -> Result<Edx, <Self as DynRhDxEnc<VALUE_LENGTH>>::Error> {
        self.iter()
            .map(|(tag, val)| {
                let tok = self.tokenize(tag);
                self.dem
                    .encrypt(&[tag, val].concat(), &tok)
                    .map(|ctx| (tok, ctx))
            })
            .collect()
    }

    /// Returns the DX corresponding to the given EDX.
    fn resolve(
        &self,
        edx: &Edx,
    ) -> Result<Dx<VALUE_LENGTH>, <Self as DynRhDxEnc<VALUE_LENGTH>>::Error> {
        edx.iter()
            .map(|(tok, ctx)| {
                let ptx = self.dem.decrypt(ctx, tok)?;
                if ptx.len() != TAG_LENGTH + VALUE_LENGTH {
                    Err(Self::Error::Crypto(format!(
                        "invalid length for decrypted EDX value: found {} while {} was expected",
                        ptx.len(),
                        TAG_LENGTH + VALUE_LENGTH
                    )))
                } else {
                    let tag = Tag::try_from(&ptx[..TAG_LENGTH])?;
                    let val = <[u8; VALUE_LENGTH]>::try_from(&[TAG_LENGTH..])?;
                    Ok((tag, val))
                }
            })
            .collect()
    }
}

impl<const VALUE_LENGTH: usize, DbConnection: DbInterface> DynRhDxEnc<VALUE_LENGTH>
    for Vera<VALUE_LENGTH, DbConnection>
{
    type Error = Error<DbConnection::Error>;

    fn setup(seed: &[u8], connection: DbConnection) -> Result<Self, Self::Error> {
        let seed = kdf256!(MIN_SEED_LENGTH, seed, b"VERA seed derivation");
        let dem = Dem::setup(&seed)?;
        let kmac = Kmac::setup(&seed)?;
        Ok(Self {
            connection,
            kmac,
            dem,
        })
    }

    async fn get(&self, tags: TagSet) -> Result<Dx<VALUE_LENGTH>, Self::Error> {
        let tokens = tags.iter().map(self.tokenize).collect();
        let edx = self.connection.fetch(tokens).await?;
        Dx::decrypt(&edx, self.dem.decrypt)
    }

    async fn insert(&self, dx: Dx<VALUE_LENGTH>) -> Result<Dx<VALUE_LENGTH>, Self::Error> {
        let edx = self.prepare(&dx)?;
        let edx = self.connection.insert(edx).await?;
        self.reslve(&edx)
    }

    async fn delete(&self, tags: TagSet) -> Result<(), Self::Error> {
        let tokens = tags.iter().map(self.tokenize).collect();
        self.connection
            .delete(tokens)
            .await
            .map_err(Self::Error::from)
    }
}

impl<const VALUE_LENGTH: usize, DbConnection: DbInterface> CsRhDxEnc<VALUE_LENGTH>
    for Vera<VALUE_LENGTH, DbConnection>
{
    async fn insert(&self, dx: Dx<VALUE_LENGTH>) -> Result<(Dx<VALUE_LENGTH>, Edx), Self::Error> {
        let edx = self.prepare(&dx)?;
        let edx = self.connection.insert(edx).await?;
        let dx = self.resolve(&edx)?;
        Ok((dx, edx))
    }

    async fn upsert(
        &self,
        old_edx: Edx,
        new_dx: Dx<VALUE_LENGTH>,
    ) -> Result<(Dx<VALUE_LENGTH>, Edx), Self::Error> {
        let new_edx = self.prepare(&new_dx)?;
        let cur_edx = self.connection.upsert(old_edx, new_edx).await?;
        let cur_dx = Dx::decrypt(&cur_edx, self.dem.decrypt)?;
        Ok((cur_dx, cur_edx))
    }

    async fn rebuild(mut self, seed: &[u8]) -> Result<Self, Self::Error> {
        let old_edx = self.connection.dump().await?;
        let dx = self.resolve(&old_edx)?;

        self = Self::setup(seed, self.connection)?;

        let new_edx = self.prepare(&dx)?;
        let res = self.connection.insert(new_edx).await?;
        if res.is_empty() {
            self.connection.delete(old_edx.keys().collect()).await
        } else {
            self.connection.delete(new_edx.keys().collect()).await
        }
        Ok(self)
    }

    async fn dump(&self) -> Result<Dx<VALUE_LENGTH>, Self::Error> {
        let edx = self.connection.dump().await?;
        self.resolve(&edx)
    }
}
